# 新增“绑定群组”接口设计

## 接口需求
- **功能**：绑定用户到群组
- **参数**：
  - 群组 ID（group_id）
  - 班级名称（group_name）
  - 入群身份（member_type）：只能是教师或学生
- **路径**：`POST /api/v1/groups/bind`
- **不依赖**：不添加其他第三方库
- **不修改**：不更改现有代码

## 实现方案

### 1. 添加请求模型
在 `groups.py` 文件中添加一个新的 Pydantic 模型 `GroupBind`，用于验证请求参数：
```python
class GroupBind(BaseModel):
    """绑定群组请求体"""
    group_id: str
    group_name: str
    member_type: str  # 只能是 teacher 或 student
    member_id: int     # 用户内部 ID
    role: str = "member"  # 成员角色：member 或 admin
```

### 2. 新增绑定群组接口
在 `groups.py` 文件中添加一个新的路由函数 `bind_group`：
```python
@router.post(
    "/bind",
    summary="绑定群组",
    description="将用户绑定到指定群组"
)
async def bind_group(payload: GroupBind, current_user: dict = Depends(get_current_user)):
    """绑定用户到群组的实现"""
    # 验证入群身份
    if payload.member_type not in ["teacher", "student"]:
        raise HTTPException(status_code=400, detail="入群身份只能是教师或学生")
    
    # 验证角色
    if payload.role not in ["member", "admin"]:
        raise HTTPException(status_code=400, detail="角色必须是 member 或 admin")
    
    conn = get_connection()
    cursor = None
    try:
        cursor = conn.cursor()
        
        # 验证群组是否存在
        cursor.execute("SELECT 1 FROM `groups` WHERE `group_id` = %s", (payload.group_id,))
        if not cursor.fetchone():
            # 群组不存在，创建新群组
            cursor.execute("""
                INSERT INTO `groups` (`group_id`, `group_name`, `description`)
                VALUES (%s, %s, %s)
            """, (payload.group_id, payload.group_name, None))
        
        # 验证用户是否存在
        table_map = {"teacher": "teachers", "student": "students"}
        cursor.execute(f"SELECT 1 FROM `{table_map[payload.member_type]}` WHERE `id` = %s", (payload.member_id,))
        if not cursor.fetchone():
            raise HTTPException(status_code=404, detail=f"用户 ID {payload.member_id} 不存在")
        
        # 绑定用户到群组
        cursor.execute("""
            INSERT INTO `group_members` (`group_id`, `member_id`, `member_type`, `role`, `is_active`, `joined_at`)
            VALUES (%s, %s, %s, %s, 1, NOW())
            ON DUPLICATE KEY UPDATE `is_active` = 1, `role` = VALUES(`role`), `updated_at` = NOW()
        """, (payload.group_id, payload.member_id, payload.member_type, payload.role))
        
        conn.commit()
        return {
            "group_id": payload.group_id,
            "group_name": payload.group_name,
            "member_id": payload.member_id,
            "member_type": payload.member_type,
            "role": payload.role,
            "message": "绑定成功"
        }
    except HTTPException:
        raise
    except pymysql.MySQLError as e:
        conn.rollback()
        raise HTTPException(status_code=500, detail=f"数据库错误：{str(e)}")
    finally:
        if cursor:
            cursor.close()
        conn.close()
```

### 3. 验证方案
- **测试场景 1**：绑定到现有群组
- **测试场景 2**：绑定到新群组（自动创建）
- **测试场景 3**：无效的入群身份
- **测试场景 4**：无效的角色
- **测试场景 5**：用户不存在

## 注意事项
- 不修改现有代码，只在 `groups.py` 文件末尾添加新接口
- 不添加任何第三方库
- 确保接口参数验证正确
- 处理数据库事务和错误